from subprocess import Popen, PIPE
import threading
import fcntl
import os
import Queue
import cmd
from random import *

""" ApoBadgeV03
#define eeprom_NumGenes 0
#define eeprom_CRC16    1 //16-bit checksum of genes
#define eeprom_genes_start 10
"""
eeprom_NumGenes    =0
eeprom_CRC16       =1 #16-bit checksum of genes
eeprom_genes_start =10


class BadgeCmd(cmd.Cmd):
    prompt = 'ApoCmd: '
    intro =  "ApoBadge2017 auto-programmer.  SPECTER v.01 build5.19.17" 


    def do_handcode_eeprom(self, line):
        print("syntax: Gene#=0xEffectColorset  example: 0=0D07 sets 0 to effect D(13) and colorset 7")
        lsplit = line.split("=")
        if lsplit != 2:
             return false
        genenum = int(lsplit[0],16)
        genecode = int(lsplit[1],16)
        address = eeprom_genes_start + genenum * 2
        #write loveliness to the /tmp directory using random filename
        temp_hex_fname = "ApoWrite"+str(hex(randint(0xFFFF)))
        
    def do_EOF(self, line):
        return True
"""
INTEL HEX file format
A record (line of text) consists of six fields (parts) that appear in order from left to right:

    Start code, one character, an ASCII colon ':'.
    Byte count, two hex digits, indicating the number of bytes (hex digit pairs) in the data field. The maximum byte count is 255 (0xFF). 16 (0x10) and 32 (0x20) are commonly used byte counts.
    Address, four hex digits, representing the 16-bit beginning memory address offset of the data. The physical address of the data is computed by adding this offset to a previously established base address, thus allowing memory addressing beyond the 64 kilobyte limit of 16-bit addresses. The base address, which defaults to zero, can be changed by various types of records. Base addresses and address offsets are always expressed as big endian values.
    Record type (see record types below), two hex digits, 00 to 05, defining the meaning of the data field.
    Data, a sequence of n bytes of data, represented by 2n hex digits. Some records omit this field (n equals zero). The meaning and interpretation of data bytes depends on the application.
    Checksum, two hex digits, a computed value that can be used to verify the record has no errors.
"""
def calc_ihex_checksum(startaddress,bytelist):
    csum = len(bytelist)
    csum += (startaddress >> 8) & 0xFF
    csum += startaddress & 0xFF
    
    for getbyte in range(len(bytelist)):
        csum += bytelist[getbyte]
    print(csum)
    csum = csum & 0xFF
    csum = csum ^ 0xFF
    csum += 1
    
    csum = csum % 0xFF
    return csum
    
def fab_ihexline(startaddress,bytelist):
    out = ":" #Start code
    lb = len(bytelist)
    if startaddress < 0 or startaddress > 0x1fff or lb == 0 or lb > 255:
        return False
    out += hex(lb+0x100)[-2:] #Byte count ... the same wacky string shit that I luv python for
    out += hex(startaddress+0x10000)[-4:] #Address
    out += "00" #Record type 00 - 8bit data
    for getbyte in range(lb):
        out += hex(bytelist[getbyte]+0x100)[-2:] #Data
    out += hex(calc_ihex_checksum(startaddress,bytelist)+0x100)[-2:] #checksum
    out += "\n"
    return(out)

def setNonBlocking(fd):
    """
    Set the file description of the given file descriptor to non-blocking.
    """
    flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    flags = flags | os.O_NONBLOCK
    fcntl.fcntl(fd, fcntl.F_SETFL, flags)

def reader(fd, queue):
    while True:
        try:
            data = fd.read()
            queue.put(data)
        except IOError:
            continue
        except Exception:
            return

def flushAndWrite(msg, p):
    p.stdout.flush()
    p.stderr.flush()
    p.stdin.write(msg)
    p.stdin.flush()

def writeAndReadResponse(msg, infd, outfd):
    outfd.flush()
    infd.write(msg)
    infd.flush()
    while True:
        try:
            return outfd.read()
        except IOError:
            continue
        except KeyboardInterrupt:
            return ''


def getVtarget(msg):
    lines = msg.split('\n')
    for line in lines:
        if line.startswith('Vtarget'):
            return float(line.split(':')[1][:-2])
    return 0.0


if __name__ == '__main__':
    eeprom_0xFF_chars = "01020304050607080910" #test data
    eeprom_shadow = bytearray(eeprom_0xFF_chars.decode("hex")) # fill eeprom_shadow with 0xFF
    print(fab_ihexline(0x0000,eeprom_shadow)) #just a test of FAB. 
    
    BadgeCmd().cmdloop()

    p = Popen("avrdude -c avrispmkii -p m328p -P usb -F -t", shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    setNonBlocking(p.stdout)
    setNonBlocking(p.stderr)
    avrdude = str(p.communicate())
    avrresponse_initok = "AVR device initialized"
    if (avrdude.find(avrresponse_initok)):
        print("Avrdude connected successfully to badge")
    else:
        print("Failed to connect to badge")
    print(avrdude)

    outqueue = Queue.Queue()
    errqueue = Queue.Queue()
    #
    outthread = threading.Thread(target=reader, args=(p.stdout, outqueue))
    errthread = threading.Thread(target=reader, args=(p.stderr, errqueue))
    #
    outthread.start()
    errthread.start()
